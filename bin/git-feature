#!/bin/bash
##>Git subcommand to manage features

TMPFILE=/tmp/featuretmp
HOOKRELPATH=../hooks
VER="v0.1.03"


if ! GITDIR=$(git rev-parse --git-dir); then
    exit 1
fi

################################################################################
#   Manage colors (see http://wiki.bash-hackers.org/scripting/terminalcodes )
################################################################################

GREEN="\\033[1;32m"
NORMAL="\\033[0;39m"
RED="\\033[1;31m"
PINK="\\033[1;35m"
BLUE="\\033[1;34m"
WHITE="\\033[0;02m"
LIGHT="\\033[1;08m"
YELLOW="\\033[1;33m"
CYAN="\\033[1;36m"
UNDERLINE="\\033[04;39m"
INVERTED="\\033[07;39m"
BLINK="\\033[05;39m"
BOLD="\\033[01;39m"


ERRCOL="$NORMAL$RED"
WARNCOL="\\033[0;37;44;1m"
IMPORTANT="$NORMAL$UNDERLINE$GREEN"
TITLE="$NORMAL$UNDERLINE$BOLD"
HIGHLIGHT="$NORMAL$BOLD$GREEN"

echoerr()
{
    echo -e "$ERRCOL$1$NORMAL"
}

echowarn()
{
    echo -e "$WARNCOL$1$NORMAL"
}

echoimportant()
{
    echo -e "$IMPORTANT$1$NORMAL"
}


menuselect()
{
    echo "-----------------"
    MENUITEMS="$(echo -e "$1" | cat -n)"
    if ! dialog --menu "$2" 40 100 15 $MENUITEMS  2> "$TMPFILE"; then
        return 1
    fi
    echo -e "$MENUITEMS" | sed "/^\s*$(<"$TMPFILE")/!D;s/^\s*\w*\s*//" > "$TMPFILE"
}

initialize()
{
    if INST_VER=$(git config workflow.feature); then
        if [ "$INST_VER" == "$VER" ]; then
            echo "Feature management already initialized"
            return
        else
            echo "Update git feature from $INST_VER to $VER"
            UPDATE=1
        fi
    fi

    if [ ! "$UPDATE" == 1 ]; then
        git config workflow.fetchinter 24

        CANDIDATES=$(git branch -a | \
            sed '/(.*)/D;/final\//D;
        /draft\//D;
        /start\//D;
        /test\//D;
        /tmp\//D;
        /->/D;s/^.\s*//')
        if ! menuselect "$CANDIDATES" "Choose the main devel branch"; then
            echo ""
            echo "Initialization aborted"
            exit
        fi
        DEVREF=$(<"$TMPFILE")


        if ! menuselect "$(git remote)" "Choose your public repo where you will push"; then
            echo ""
            echo "Initialization aborted"
            exit
        fi

        REMOTE=$(<"$TMPFILE")
        git config workflow.devref "$DEVREF"
        git config workflow.remote "$REMOTE"
    fi

    #Install hook
    HOOKPATH="$(dirname "$(readlink -f "$0")")/$HOOKRELPATH"
    echo "Getting hooks from $HOOKPATH"
    if ! cp -a "$HOOKPATH/"* $GITDIR/hooks/; then
        exit
    fi

    git config workflow.feature $VER

    #Set alias
    git config alias.featpush "feature -p"
    git config alias.featpushall "feature -P"
    git config alias.featmove "feature -m"
    git config alias.featclose "feature -a close"
    git config alias.featreview "feature -r"
    git config alias.featfinalize "feature -f"
    git config alias.featupdate "feature -u"
    git config alias.featintegrate "feature -i"
    git config alias.featview "feature -v"
    git config alias.featviewall "feature -a view all"
    git config alias.featlist "feature -l"
}

usage()
{
cat << EOF
usage: git feature options

This script create new and manage feature branches :
git feature [options] featurename

Default action is creating a new branch, other are provided through options
OPTIONS:
   -a      Perform the given action
            > close : Check the feature is integrated and destroy all branches
            > devref : Change the devref ( it must always contain the old one )
            > finalize : Finalize the feature
            > init : Initialize current repository to handle features
            > merge : Merge all features in a single branch
            > update : Update the specified feature using rebase
            > view : View local features and there remote updates
            > view all : View local features and all updated remote features
   -b      Give a specific branch on which to base the new feature
   -c      Check feature (push and final)
   -f      Finalize the feature.
   -h      Display this help.
   -i      Include feature in current branch
   -l      List all features
   -m      Move the feature upon a new base
   -p      Push the given feature
   -P      Push all local features
   -r      Review commits of the branch ( git rebase -i )
   -t      Dummy option for test purpose.
   -u      Update the specified feature using rebase (Same as -a update )
   -v      View local features in gitk. Or if a remote name is specified, view
                all features of this repository

ALIAS:
The following alias can be used:
    > featpush			"feature -p"
    > featpushall		"feature -P"
    > featmove			"feature -m"
    > featclose			"feature -a close"
    > featreview		"feature -r"
    > featfinalize		"feature -f"
    > featupdate		"feature -u"
    > featintegrate		"feature -i"
    > featview			"feature -v"
    > featviewall		"feature -a view all"
    > featlist			"feature -l"

EOF
}

################################################################################
#   Get arguments
################################################################################

DO='n' # Default action is new feature

while getopts "rfm:tb:a:hucvpliP" OPTION; do
    case $OPTION in
        a)
            case $OPTARG in
                merge)
                    echo 'Merge not implemented yet.'
                    exit
                    ;;
                finalize)
                    DO='f'
                    ;;
                init)
                    echo 'Initializing feature management in your repo'
                    initialize devel
                    exit
                    ;;
                devref)
                    DO='d'
                    EXPECTED=1
                    ;;
                view)
                    DO='v'
                    EXPECTED=1
                    ;;
                update)
                    DO='u'
                    ;;
                close)
                    DO='C'
                    ;;

            esac
            ;;
        c)
            DO='c'
            ;;
        b)
            FOLLOW=$OPTARG
            ;;
        u)
            DO='u'
            ;;
        m)
            MOVETO=$OPTARG
            DO='m'
            ;;
        r)
            DO='r'
            ;;
        #s)        #> Specify the feature already exists and you want to share it (take no arg)
        #    DO='e'
        #    ;;
        f)
            DO='f'
            ;;
        t)
            DO='t'
            ;;
        i)
            DO='i'
            ;;
        l)
            DO='l'
            EXPECTED=1
            ;;
        v)
            DO='v'
            EXPECTED=1
            ;;
        p)
            DO='p'
            ;;
        P)
            DO='P'
            EXPECTED=none
            ;;
        h)
            usage
            exit
    esac
done

shift $((OPTIND-1))
if [ "$EXPECTED" == none ]; then
    if [ $# -gt 0 ]; then
        echoerr "No args expected! "
        exit 1
    fi
elif [ -n "$EXPECTED" ]; then
    ARG=$1
elif [ $# == 1 ]; then
    FEATUREBRANCH=$1
elif test "$DO" != 'n' && CURRENT=$(git symbolic-ref HEAD 2> /dev/null); then
    FEATUREBRANCH=${CURRENT##refs/heads/}
else
    usage
    exit 3
fi

if [ -n "$FEATUREBRANCH" ]; then
    FEATURE=$(basename $FEATUREBRANCH)
elif [[ -z "$EXPECTED" ]]; then
    echoerr "No feature name or branch provided!"
    exit 1
fi

################################################################################
#   Check and prepare environment
################################################################################

INST_VER=$(git config workflow.feature)
if [[ ! "$INST_VER" == "$VER" ]]; then
    echoerr "Feature is not installed or needs to be updated"
    echo "Run git feature -a init"
    exit -1
fi

if ! DEVREF=$(git config workflow.devref); then
    echoerr "The git config workflow.devref parameter must be define"
    exit 6
fi

DEVREFHASH=$(git rev-parse $DEVREF)
STARTNAMESPACE='start'
DRAFTNAMESPACE='draft'
FINALNAMESPACE='final'
FEATURESTART="$STARTNAMESPACE/$FEATURE"
FEATUREDRAFT="$DRAFTNAMESPACE/$FEATURE"
FEATUREFINAL="$FINALNAMESPACE/$FEATURE"

#Check if the feature name already exists
EXISTING="$(git show-ref $FEATURE)"
EXISTDRAFT="$(echo -e "$EXISTING" | grep "$FEATUREDRAFT" )"
EXISTFINAL="$(echo -e "$EXISTING" | grep "$FEATUREFINAL" )"

if [ ! "$FEATURE" == "$FEATUREBRANCH" ]; then
    FEATUREDIR=$(dirname $FEATUREBRANCH)
    FEATURENAMESPACE=$(basename $FEATUREDIR)
    FEATUREREMOTE=$(dirname $FEATUREDIR)

    if [[ ! ( "$FEATURENAMESPACE" == "$DRAFTNAMESPACE" || "$FEATURENAMESPACE" == "$FINALNAMESPACE" ) ]]; then
        echoerr "Invalid domain $FEATURENAMESPACE.\
            You must provide a $FEATUREDRAFT or a $FEATUREFINAL feature branch."
        exit 20
    fi
else
    if [[ $# == 0 && -z "$EXPECTED" ]]; then
        echoerr "You are not in a feature branch"
        echoerr "Either checkout the branch or provide the feature name in command line"
        exit 1
    fi

    FEATUREBRANCH=$DRAFTNAMESPACE/$FEATURE
fi

################################################################################
#   Function definitions
################################################################################

function start_point()
{
    WORKINGBRANCH=$1
    STARTLIST=$(git show-ref $FEATURESTART)

    #Keep only start points that are in the branch
    SELECTSTART=''
    for s in $STARTLIST; do
        DISTANCE=$(git rev-list --count $s ^$WORKINGBRANCH)
        if [ "$DISTANCE" == 0 ]; then
            SELECTSTART="$SELECTSTART$s "
        fi
    done
    STARTLIST=$SELECTSTART

    if [ -z "$STARTLIST" ]; then
        DEPEND="$(list_feat_depend $WORKINGBRANCH)"
        if [ -z "$DEPEND" ]; then
            START=$DEVREF
        else
            echoerr "Features are detected between $DEVREF and $WORKINGBRANCH but there is no 'start'" >&2
            echo 'marker *'"$FEATURESTART. Detected features are :" >&2
            echo -e "$DEPEND" >&2
            echo '------------------------------------------------------------' >&2
            echo 'You should check it before making operations on your feature' >&2
            exit 1
        fi
    else
        if [ "$(echo -e "$STARTLIST"|wc -l)" == 1 ]; then
            #If there is only one start point it is used
            START=$(echo -e "$STARTLIST" | sed 's#^.*refs/\w*/\(.*\)\s*$#\1#')
        elif echo -e "$STARTLIST" | grep refs/heads/$FEATURESTART &> /dev/null ; then
            #Is there a local start point
            START=$FEATURESTART
        else
            #A remote start point must be chosen
            echoerr "Several remote start points are found :" >&2
            echo -e "$STARTLIST" >&2
            echo '------------------------------------------------------------' >&2
            echo "Are you sure this is normal. If you are sure tell me wich I have to use by creating a local one" >&2
            exit 1
        fi
    fi
    echo $START
}

#List features on which we are based
function list_feat_depend()
{
    WORKINGBRANCH=$1
    LIST=$(git rev-list  --simplify-by-decoration --pretty='format:%d' "$WORKINGBRANCH" "^$DEVREF" | \
        sed '/^\s*(/H;$!D;$g;s/[(), \n]\+/\n/g' | \
        sed "/$FEATURE"'$/D;'"/$DRAFTNAMESPACE"'\/\w*$/H;'"/$FINALNAMESPACE"'\/\w*$/H;$!D;$g' | \
        sed 's/^\s*$//')

    echo -e "$LIST"
}

function branch_list()
{
    git branch $@ | sed 's/^.\s*//'
}

function check_included()
{
    featbranch=$1
    featname=$(basename $featbranch)
    git rev-list $DEVREF ^$featbranch^ --simplify-by-decoration --pretty='format:%d' \
        |egrep '@'$featname'_[0-9]{1,}\b' &> /dev/null \
        && return 0

    return 1
}

function check_final()
{
    featname=$(basename $1)
    finalname=$FINALNAMESPACE/$featname
    finallist=$(branch_list --list $finalname)
    if [ -n "$finallist" ]; then
        finallist="$finallist "
    fi
    finallist=$finallist$(branch_list -r --contains $DEVREF --list '*/'$finalname)
    if [ -z "$finallist" ]; then
        finallist=$(branch_list -r --list '*/'$finalname)
    fi

    echo "$finallist"
}

function check_local()
{
    featname=$(basename $1)
    finalname=$FINALNAMESPACE/$featname
    draftname=$DRAFTNAMESPACE/$featname
    R=1
    if git rev-parse $finalname &> /dev/null; then
        echo $finalname
        R=0
    fi
    if git rev-parse $draftname &> /dev/null; then
        echo $draftname
        R=0
    fi

    return $R
}

function get_feat_ref()
{
    FEATREMOTE=$(git config branch."$FEATUREDRAFT".remote)
    FEATREBASE=$(git config branch."$FEATUREDRAFT".merge \
        | sed 's#refs/\w*/##')
    if [ -n "$FEATREBASE" ]; then
        if [ "$FEATREMOTE" == '.' ]; then
            echo "$FEATREBASE"
        else
            echo "$FEATREMOTE/$FEATREBASE"
        fi
    else
        echo "$DEVREF"
    fi
}

function list_locals()
{
    LOCALFEAT=$(branch_list --list 'draft/*')
    LOCALFEAT="$LOCALFEAT $(branch_list --list 'final/*')"
    FEATLIST=''
    for feat in $LOCALFEAT; do
        if ! check_included $feat; then
            finalfeat=$(check_final $feat)
            if [ -z "$finalfeat" ]; then
                FEATLIST="$FEATLIST$feat "
                FEATLIST="$FEATLIST$(branch_list -r --contains $DEVREF --list '*/'$feat) "
            else
                FEATLIST="$FEATLIST$finalfeat "
            fi
        fi
    done

    echo $FEATLIST
}

function list_remotes()
{
    REMOTENAME="$1"
    REMOTEFEAT=$(branch_list -r --list $1'/draft/*')
    REMOTEFEAT="$REMOTEFEAT $(branch_list -r --list $1'/final/*')"
    FEATLIST=''
    for feat in $REMOTEFEAT; do
        if ! check_included $feat; then
            finalfeat=$(check_final $feat)
            if [ -z "$finalfeat" ]; then
                FEATLIST="$FEATLIST$feat "
                FEATLIST="$FEATLIST$(check_local $feat) "
            else
                FEATLIST="$FEATLIST$finalfeat "
            fi
        fi
    done

    echo $FEATLIST
}

function list_updated_remote()
{
    REMOTEFEAT=$(branch_list -r --contains $DEVREF --list '*/draft/*')
    FEATLIST=''
    for feat in $REMOTEFEAT; do
        finalfeat=$(check_final $feat)
        if [ -z "$finalfeat" ]; then
            FEATLIST="$FEATLIST$finalfeat "
        else
            FEATLIST="$FEATLIST$feat "
        fi
    done

    echo $REMOTEFEAT
}

function check_remote()
{
    ERR=0
    REMOTE=$(git config workflow.remote)
    LIST=$(git branch -r --list "$REMOTE/$FINALNAMESPACE"'/*')
    LIST="$LIST $(git branch -r --list "$REMOTE/$DRAFTNAMESPACE"'/*')"
    for b in $LIST; do
        feat=$(basename $b)
        if git rev-parse $STARTNAMESPACE/$feat &> /dev/null; then
            if ! git rev-parse $REMOTE/$STARTNAMESPACE/$feat &> /dev/null; then
                echo "# > Feature $feat is not correctly pushed! You must run"
                echo "git push $REMOTE $STARTNAMESPACE/$feat"
                ERR=1
            fi
        fi
    done
    return $ERR
}

function push_feat()
{
    ARGFEAT=$(basename "$1")
    ARGFEATFINAL=$FINALNAMESPACE/$ARGFEAT
    ARGFEATDRAFT=$DRAFTNAMESPACE/$ARGFEAT
    ARGFEATSTART=$STARTNAMESPACE/$ARGFEAT
    REMOTE=$(git config workflow.remote)
    if git rev-parse $ARGFEATFINAL &> /dev/null; then
        git push -f $REMOTE $ARGFEATFINAL
        if git rev-parse $REMOTE/$ARGFEATDRAFT &> /dev/null; then
            git push -f $REMOTE :$ARGFEATDRAFT
        fi
    elif git show-rev $ARGFEATFINAL &> /dev/null; then 
        if git rev-parse $REMOTE/$ARGFEATDRAFT &> /dev/null; then
            git push -f $REMOTE :$ARGFEATDRAFT
        fi
    elif git rev-parse $ARGFEATDRAFT &> /dev/null; then
        git push -f $REMOTE $ARGFEATDRAFT
    fi 
    if git rev-parse $ARGFEATSTART &> /dev/null; then
        git push -f $REMOTE $ARGFEATSTART
    fi
}

#Check the state of features on which we are based
# function check_feat_depend()
# {
# }

################################################################################
#   Proceed
################################################################################
if test "$DO" != 'p' && ! check_remote; then
    exit 1
fi


#Change DEVREF
if [ "$DO" == 'd' ]; then
    #git branch --contains $DEVREF
    if test -n "$ARG" && git rev-parse "$ARG" &> /dev/null ; then
        NEWREF=$ARG
        #Check if new reference contains old reference
        if [ -n "$(git rev-list $DEVREF ^$NEWREF)" ]; then
            echoerr "The new devel reference must contain $DEVREF"
            exit 1
        fi
    else
        CANDIDATES=$(git branch --contains $DEVREF | sed 's/^.\s*//')
        menuselect "$CANDIDATES" "Choose the main devel branch"
        NEWREF=$(<"$TMPFILE")
    fi

    echo ""
    echoimportant "New devel reference is $NEWREF"
    git config workflow.devref $NEWREF
    exit

#Close the feature
elif [ "$DO" == 'C' ]; then
    if [ -z "$EXISTFINAL" ]; then
        echo -e $ERRCOL"The feature is not even finalized. "$NORMAL"Nothing to do!"
        exit 1
    fi

    if [ -z "$(git tag --list '@'$FEATURE'_*')" ]; then
        echoerr "Integration tag not found. The feature cannot be closed"
        exit 1
    fi

    git rev-parse $FEATUREDRAFT &> /dev/null && git branch -D $FEATUREDRAFT
    git rev-parse $FEATUREFINAL &> /dev/null && git branch -D $FEATUREFINAL
    git rev-parse $FEATURESTART &> /dev/null && git branch -D $FEATURESTART

    exit

elif [ "$DO" == 'i' ]; then
    FEATREBASEDIR=$GITDIR/feat_rebase
    if [ -f "$FEATREBASEDIR/integration" ]; then
        echoimportant "JUST CLEAN THE PREVIOUS INTEGRATION"
        FEATURE="$(<"$FEATREBASEDIR/integration")"
        POSTCHECKOUT="$(<"$FEATREBASEDIR/postcheckout")"
        test -n "$POSTCHECKOUT" && git checkout "$POSTCHECKOUT" &&
        test -n "$FEATURE" && git branch -D "integrate/$FEATURE" &&
        rm "$FEATREBASEDIR"/* &&
        echo "Integration succesfull"
        exit
    fi
    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "Your repository must be clean"
        echo "Please commit all changes before running it!"
        exit 2
    fi

    if ! CURRENT=$(git symbolic-ref HEAD 2> /dev/null); then
        echoerr "You must be in a valid local branch for include operation!"
        exit 1
    fi
    CURRENTBRANCH=${CURRENT##refs/heads/}

    echo "Including $FEATURE in $CURRENTBRANCH"
    if [ -z "$EXISTFINAL" ]; then
        echo "No final branch found for inclusion of $FEATURE"
        exit 1
    fi

    ABOVEREF=$(branch_list -a --contains $DEVREF --list '*'"$FEATUREFINAL")
    if [ $(echo -e "$EXISTFINAL" | wc -l) == 1 ]; then
        CHOSENFINAL=$(echo -e "$EXISTFINAL" | sed 's#^.*refs/\w*/\(.*\)\s*$#\1#')
    elif [ -n "$ABOVEREF" && $(echo -e "$ABOVEREF" | wc -l) == 1 ]; then
        CHOSENFINAL=$ABOVEREF
    else
        if ! menuselect "$EXISTFINAL" "Choose a final reference for the feature $FEATURE"; then
            exit
        fi
        CHOSENFINAL=$(sed 's#^.*refs/\w*/\(.*\)\s*$#\1#' "$TMPFILE")
    fi

    #Get NEWBASE SHA-1
    NEWBASE=$(git rev-parse HEAD)
    STARTPOINT=$(start_point $FEATUREBRANCH) || exit 1

    if [[ "$(git rev-parse $STARTPOINT)" == "$(git rev-parse HEAD)" && -z "$(git rev-list "^$CHOSENFINAL" "$DEVREF")" ]]; then
        git rebase $CHOSENFINAL
        git tag '@'$FEATURE"_$(date '+%s')"
    else
        FEATUREINTEGRATE=integrate/$FEATURE
        git branch -f $FEATUREINTEGRATE $CHOSENFINAL

        export INTEGRATION=$FEATURE
        export POSTCHECKOUT=$CURRENTBRANCH
        echo git rebase --onto $NEWBASE $STARTPOINT $FEATUREINTEGRATE
        git rebase --onto $NEWBASE $STARTPOINT $FEATUREINTEGRATE
    fi

    exit

#Push feature
elif [ "$DO" == 'p' ]; then
    push_feat "$FEATURE"
    exit

elif [ "$DO" == 'P' ]; then
    for feat in $(branch_list --list "$DRAFTNAMESPACE"/'*'); do
        if [ -z "$(git rev-parse "$FINALNAMESPACE/$feat" &> /dev/null)" ]; then
            push_feat $feat
        fi
    done

    for feat in $(branch_list --list "$FINALNAMESPACE"/'*'); do
        push_feat $feat
    done

    exit
        
#Check feature
elif [ "$DO" == 'c' ]; then
    exit

#View using gitk
elif [ "$DO" == 'v' ]; then
    BRANCHLIST=""
    echo "Getting list of branch ..."
    BRANCHLIST=$(list_locals)
    if [ "$ARG" == all ]; then
        BRANCHLIST="$BRANCHLIST $(list_updated_remote)"
    elif [ -n "$ARG" ]; then
        REMOTENAME="$ARG"
        BRANCHLIST="$(list_remotes $REMOTENAME)"
    fi

    BRANCHLIST="$BRANCHLIST $DEVREF"
    echo $BRANCHLIST
    echo "---------------------------------------"
    gitk $BRANCHLIST

    exit

#List features
elif [ "$DO" == 'l' ]; then
    #If ARG is not empty it is the remote name
    if [ -z "$ARG" ]; then
        FEATLIST=$(branch_list --list 'draft/*')
        FEATPREFIX=''
    else
        FEATLIST=$(branch_list -r --list $ARG'/draft/*')
        FEATPREFIX=$ARG/
    fi

    CURRENT=''
    REMOTES=''
    INCLUDED=''
    FINALS=''

    for feat in $FEATLIST; do
        finalfeat=$(check_final $feat)
        if [ -z "$finalfeat" ]; then
            if ! check_included $feat; then
                CURRENT="$CURRENT$feat "
            else
                INCLUDED="$INCLUDED$feat "
            fi
        elif ! git rev-parse $FEATPREFIX'final/'$feat &> /dev/null; then
            if ! check_included $feat; then
                FINALS="$FINALS$finalfeat "
            else
                INCLUDED="$INCLUDED$feat "
            fi
        fi
    done

    if [ -z "$ARG" ]; then
        FEATLIST=$(branch_list --list 'final/*')
    else
        FEATLIST=$(branch_list -r --list $ARG'/final/*')
    fi

    CURRENT=$CURRENT$HIGHLIGHT
    CURRENT="$CURRENT$FINALS "
    for feat in $FEATLIST; do
        if ! check_included $feat; then
            CURRENT="$CURRENT$feat "
        else
            INCLUDED="$INCLUDED$feat "
        fi
    done
    CURRENT=$CURRENT$NORMAL

    echo "List local features"
    echo ""
    echo -e $TITLE"Included features"$NORMAL
    for feat in $INCLUDED; do
        echo -e "    $ERRCOL$feat$NORMAL"
    done
    echo ""
    echo -e $TITLE"Current features"$NORMAL
    for feat in $CURRENT; do
        echo -e "    $feat"
    done
    echo ""

    exit 

#Finalize feature
elif [ "$DO" == 'f' ]; then
    if [ -z "$EXISTDRAFT" ]; then
        echoerr "No draft branch found for feature $FEATURE found!"
        exit 4
    fi

    if [ -n "$EXISTFINAL" ]; then
        echoerr "$FEATURE is already being finalized by you or someone else." ' *'/$FEATUREFINAL branches are detected.
        echo -e "$EXISTFINAL"
        exit 5
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point $FEATUREBRANCH) || exit 1

    git branch -t $FEATUREFINAL $STARTPOINT
    git branch -f $FEATUREFINAL $FEATUREBRANCH
    #Check if STARTPOINT is in DEVREF line
    if [ $(git rev-list --count $STARTPOINT ^$DEVREF) == 0 ]; then
        git rebase -i $DEVREF $FEATUREFINAL
    else
        #Unsure there is a local start point
        git branch -f $FEATURESTART $STARTPOINT
        git rebase -i $STARTPOINT $FEATUREFINAL
    fi

    exit
elif [ "$DO" == 'm' ]; then
    if [ -n "$EXISTFINAL" ]; then
        if ! git rev-parse $FEATUREFINAL &> /dev/null; then
            echoerr "$FEATURE is already being finalized by someone else." ' *'/$FEATUREFINAL branches are detected.
            echo -e "$EXISTFINAL"
            echo 'But there is no local final branch.'
            echo "You cannot move a remote final branch"
            exit 5
        fi
        FEATUREBRANCH=$FEATUREFINAL
    elif ! git rev-parse $FEATUREDRAFT &> /dev/null; then
        echoerr "No local branch $FEATUREDRAFT to move"
        exit 10
    else
        FEATUREBRANCH=$FEATUREDRAFT
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    echo '>> '$STARTPOINT

    #If there is start marker or if new base does not coincide with DEVREF,
    # a start_point must be created or moved
    if git show-ref $FEATURESTART &> /dev/null || test $(git rev-list --count ^$DEVREF $MOVETO) != 0
    then
        export NEWSTARTPOINT=$MOVETO
    fi
    echo git rebase --onto $MOVETO $STARTPOINT $FEATUREBRANCH
    git rebase --onto $MOVETO $STARTPOINT $FEATUREBRANCH
    exit

elif [ "$DO" == 'r' ]; then
    if [ -n "$EXISTFINAL" ]; then
        if ! git rev-parse $FEATUREFINAL &> /dev/null; then
            echoerr "$FEATURE is already being finalized by you or someone else." ' *'/$FEATUREFINAL branches are detected.
            echo -e "$EXISTFINAL"
            echo "You should not move a feature being finalizd"
            exit 5
        fi
        FEATUREBRANCH=$FEATUREFINAL
    elif ! git rev-parse $FEATUREDRAFT &> /dev/null; then
        echoerr "No local branch $FEATUREDRAFT to move"
        exit 10
    else
        FEATUREBRANCH=$FEATUREDRAFT
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    git checkout $FEATUREBRANCH
    git rebase -i $STARTPOINT
    exit

elif [ "$DO" == 'u' ]; then
    #Check if no final branch
    if [ -n "$EXISTFINAL" ]; then
        #Check if the branch is local
        if ! git rev-parse $FEATUREFINAL &> /dev/null; then
            echoerr "This operation can only be done on local final branch"
            exit 10
        fi
        FEATUREBRANCH=$FEATUREFINAL
    else
        #Check if the branch is local
        if ! git rev-parse $FEATUREDRAFT &> /dev/null; then
            echoerr "This operation can only be done on local draft branch"
            exit 10
        fi
        FEATUREBRANCH=$FEATUREDRAFT
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi


    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    FEATUREBASE=$(get_feat_ref)
    #TODO Check for other refs between start point and branch end.
    if [ "$(git rev-parse $STARTPOINT)" == "$DEVREFHASH" ]; then
        git checkout "$FEATUREBRANCH"
        git rebase $DEVREF
    elif [ -z "$(git rev-list ^$FEATUREBASE $DEVREF)" ]; then
        echo git rebase --onto "$FEATUREBASE" "$STARTPOINT" "$FEATUREBRANCH"
        git rebase --onto "$FEATUREBASE" "$STARTPOINT" "$FEATUREBRANCH"
    else
        echoerr "Previous feature $FEATUREBASE is not updated"
        echo "Rebase everything on devel"
        export BRANCHREPORT=$STARTPOINT
        git rebase $DEVREF $FEATUREBRANCH
    fi
    exit

elif [ "$DO" == 'e' ]; then
    # ====== Not used now =======
    if [ -z "$EXISTING" ]; then
        echoerr "No feature $FEATURE found!"
        exit 4
    fi

    dialog --menu "Choose which branch you to be based on" 40 100 15 1 $EXISTING 2> "$TMPFILE"

elif [ "$DO" == 't' ]; then
    echo FEATURE      : $FEATURE
    echo DEVREF       : $DEVREF
    echo DEVREFHASH   : $DEVREFHASH
    echo STARTNAMESPACE  : $STARTNAMESPACE
    echo DRAFTNAMESPACE  : $DRAFTNAMESPACE
    echo FINALNAMESPACE  : $FINALNAMESPACE
    echo FEATURESTART : $FEATURESTART
    echo FEATUREDRAFT : $FEATUREDRAFT
    echo FEATUREFINAL : $FEATUREFINAL
    echo EXISTING     : $EXISTING
    echo EXISTDRAFT   : $EXISTDRAFT
    echo EXISTFINAL   : $EXISTFINAL
    echo FEATUREDIR   : $FEATUREDIR
    echo FEATUREBRANCH : $FEATUREBRANCH
    echo FEATURENAMESPACE : $FEATURENAMESPACE
    echo FEATUREREMOTE : $FEATUREREMOTE

    echoimportant 'start > '$(start_point $FEATUREBRANCH)
    echowarn "Do nothing ..."
    exit

else
    if [ -n "$EXISTING" ]; then
        echoerr "The name $FEATURE has been found in existing branches"
        echo "Choose another name for your new feature"
        exit 5
    fi

    if [ -z "$FOLLOW" ]; then
        FOLLOW="$DEVREF"
    fi
fi

DISTANCE=$(git rev-list --count $DEVREF ^$FOLLOW)
if [ ! "$DISTANCE" == 0 ]; then
    echoerr "Your base must contain the main devel branch : $DEVREF"
    echo "Ensure your base is correct and / or rebase it if needed before creating your new feature"
    exit 7
fi

if [ ! "$(git rev-parse $FOLLOW)" == "$DEVREFHASH" ]; then
    echoerr "Provide distant start point"
    git branch $FEATURESTART $FOLLOW
fi
git branch -t $FEATUREDRAFT $FOLLOW
git config branch.$FEATUREDRAFT.rebase true

echo "You can now implement your new feature in branch $FEATUREDRAFT"

#Check if repo is clean
if ! git diff --quiet HEAD; then
    echowarn "It can't be checked out now because your repository is not clean now"
    echo "you can get it by > git checkout $FEATUREDRAFT"
    echo "but you should FIRST CLEAN YOUR REPOSITORY"
else
    git checkout $FEATUREDRAFT
fi


