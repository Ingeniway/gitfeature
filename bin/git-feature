#!/bin/bash
##>Git subcommand to manage features

PYPATH="$(dirname "$(readlink -f "$0")")"/../python
TMPFILE=/tmp/featuretmp.$USER
HOOKRELPATH=../hooks
VER="v0.1.06"


if ! GITDIR="$(git rev-parse --git-dir)"; then
    exit 1
fi

################################################################################
#   Manage colors (see http://wiki.bash-hackers.org/scripting/terminalcodes )
################################################################################

GREEN="\\033[1;32m"
NORMAL="\\033[0;39m"
RED="\\033[1;31m"
PINK="\\033[1;35m"
BLUE="\\033[1;34m"
WHITE="\\033[0;02m"
LIGHT="\\033[1;08m"
YELLOW="\\033[1;33m"
CYAN="\\033[1;36m"
UNDERLINE="\\033[04;39m"
INVERTED="\\033[07;39m"
BLINK="\\033[05;39m"
BOLD="\\033[01;39m"
GREENBOLD="\\033[01;32m"


ERRCOL="$NORMAL$RED"
WARNCOL="\\033[0;37;44;1m"
IMPORTANT="$NORMAL$UNDERLINE$GREEN"
TITLE="$NORMAL$UNDERLINE$BOLD"
HIGHLIGHT="$NORMAL$GREENBOLD"

echoerr()
{
    echo -e "$ERRCOL$1$NORMAL" >&2
}

echowarn()
{
    echo -e "$WARNCOL$1$NORMAL"
}

echoimportant()
{
    echo -e "$IMPORTANT$1$NORMAL"
}

repeatchar()
{
    A=$(seq $1)
    echo ${A//??/$2}
}

menuselect()
{
    echo "-----------------"
    if [ "$3" == '-d' ]; then
        MENUITEMS="$1"
    else
        MENUITEMS="$(echo -e "$1" | cat -n)"
    fi
    if ! dialog --menu "$2" 50 130 50 $MENUITEMS  2> "$TMPFILE"; then
        return 1
    fi
    echo -e "$MENUITEMS" | sed "/^\s*$(<"$TMPFILE")/!D;s/^\s*\w*\s*//" > "$TMPFILE"
}

multiselect()
{
    echo "-----------------"
    #MENUITEMS="$(echo -e "$1" | cat -n)"
    if ! dialog --checklist "$2" 50 130 50 $1  2> "$TMPFILE"; then
        return 1
    fi
}


initialize()
{
    if INST_VER=$(git config workflow.feature); then
        if [ "$INST_VER" == "$VER" ]; then
            echo "Feature management already initialized"
            return
        else
            echo "Update git feature from $INST_VER to $VER"
            UPDATE=1
        fi
    fi

    if [ ! "$UPDATE" == 1 ]; then
        git config workflow.fetchinter 24

        CANDIDATES=$(git branch -a | \
            sed '/(.*)/D;/final\//D;
        /draft\//D;
        /start\//D;
        /test\//D;
        /tmp\//D;
        /->/D;s/^.\s*//')
        if ! menuselect "$CANDIDATES" "Choose the main devel branch"; then
            echo ""
            echo "Initialization aborted"
            exit
        fi
        DEVREF=$(<"$TMPFILE")


        if ! menuselect "$(git remote)" "Choose your public repo where you will push"; then
            echo ""
            echo "Initialization aborted"
            exit
        fi

        REMOTE=$(<"$TMPFILE")
        git config workflow.devref "$DEVREF"
        git config workflow.remote "$REMOTE"
        if is_local $DEVREF; then
            git update-ref refs/markers/devref $DEVREF
        fi
    fi

    #Install hook
    HOOKPATH="$(dirname "$(readlink -f "$0")")/$HOOKRELPATH"
    echo "Getting hooks from $HOOKPATH"
    if ! cp -a "$HOOKPATH/"* "$GITDIR/hooks/"; then
        exit
    fi

    git config workflow.feature $VER

    #Set alias
    git config alias.featpush "feature -p"
    git config alias.featpushall "feature -P"
    git config alias.featmove "feature -m"
    git config alias.featclose "feature -a close"
    git config alias.featreview "feature -r"
    git config alias.featfinalize "feature -f"
    git config alias.featupdate "feature -u"
    git config alias.featintegrate "feature -i"
    git config alias.featview "feature -v"
    git config alias.featviewall "feature -a view all"
    git config alias.featlist "feature -l"
    git config alias.feattest "feature -T"
    git config alias.featclear "feature -a clear"
    git config alias.featcherry "feature -a cherry"
}

unicref()
{
    count=0
    name=$1
    while git rev-parse $name$count &> /dev/null; do
        count=$((count+1))
    done

    echo $name$count
}

usage()
{
cat << EOF
usage: git feature options

This script create new and manage feature branches :
git feature [options] featurename

Default action is creating a new branch, other are provided through options
OPTIONS:
   -a      Perform the given action
            > close : Check the feature is integrated and destroy all branches
            > clear : Interactively close included features
            > cherry : look for commits that are (not) cherry-picked in DEVREF
                - accecpt reverse option -R for "not"
            > devref : Change the devref ( it must always contain the old one )
            > files : list files modified in all commits of the feature
            > diff : show all patch (overall diff) of the feature (all commits together)
            > finalize : Finalize the feature
            > init : Initialize current repository to handle features
            > merge : Merge all features in a single branch
            > update : Update the specified feature using rebase
            > view : View local features and there remote updates
                - accept full option -F to see all commits of DEVREF
            > view all : View local features and all updated remote features
   -b      Give a specific branch on which to base the new feature
   -c      Check feature (push and final)
   -f      Finalize the feature.
   -h      Display this help.
   -i      Include feature in current branch
               - accecpt -R (revert) option to cancel last integration
   -l      List all features
   -m      Move the feature upon a new base
                > Specify the feature on which you want to move the current feature
   -p      Push the given feature
   -P      Push all local features
   -r      Review commits of the branch ( git rebase -i )
   -t      Dummy option for test purpose.
   -T      Make a test branch
                > Allows to interactively select features to try to merge together.
   -u      Update the specified feature using rebase (Same as -a update )
   -U      Update remote DEVREF and tags (integrator only)
   -v      View local features in gitk. Or if a remote name is specified, view
                all features of this repository

ALIAS:
The following alias can be used:
    > featpush			"feature -p"
    > featpushall		"feature -P"
    > featmove			"feature -m"
    > featclose			"feature -a close"
    > featclear			"feature -a clear"
    > featcherry		"feature -a cherry"
    > featreview		"feature -r"
    > featfinalize		"feature -f"
    > featupdate		"feature -u"
    > featintegrate		"feature -i"
    > feattest			"feature -T"
    > featview			"feature -v"    (see -a view)
    > featviewall		"feature -a view all"
    > featlist			"feature -l"

EOF
}

################################################################################
#   Get arguments
################################################################################

DO='n' # Default action is new feature

while getopts "AFrfm:tb:a:hucvpliPRUsTL" OPTION; do
    case $OPTION in
        a)
            case $OPTARG in
                merge)
                    echo 'Merge not implemented yet.'
                    exit
                    ;;
                finalize)
                    DO='f'
                    ;;
                init)
                    echo 'Initializing feature management in your repo'
                    initialize devel
                    exit
                    ;;
                cherry)
                    DO='Y'
                    ;;
                devref)
                    DO='d'
                    EXPECTED=1
                    ;;
                diff)
                    DO='diff'
                    ;;
                files)
                    DO='files'
                    ;;
                view)
                    DO='v'
                    EXPECTED=1
                    ;;
                clear)
                    DO='D'
                    EXPECTED=1
                    ;;
                update)
                    DO='u'
                    ;;
                close)
                    DO='C'
                    ;;

            esac
            ;;
        A)
            ALL='y'
            ;;
        F)
            FULL='y'
            ;;
        R)
            REVERSE='y'
            ;;
        c)
            DO='c'
            ;;
        b)
            FOLLOW=$OPTARG
            ;;
        u)
            DO='u'
            ;;
        m)
            MOVETO=$OPTARG
            DO='m'
            ;;
        r)
            DO='r'
            ;;
        #s)        #> Specify the feature already exists and you want to share it (take no arg)
        #    DO='e'
        #    ;;
        f)
            DO='f'
            ;;
        t)
            DO='t'
            ;;
        L)
            DO='L'
            EXPECTED=none
            ;;
        i)
            DO='i'
            OPTFEATARG='y'
            ;;
        l)
            DO='l'
            EXPECTED=1
            ;;
        v)
            DO='v'
            EXPECTED=1
            ;;
        p)
            DO='p'
            ;;
        P)
            DO='P'
            EXPECTED=none
            ;;
        U)
            DO='U'
            EXPECTED=none
            ;;
        s)
            DO='s'
            ;;
        T)
            DO='T'
            EXPECTED=none
            ;;
        h)
            usage
            exit
    esac
done

shift $((OPTIND-1))
if [ "$EXPECTED" == none ]; then
    if [ $# -gt 0 ]; then
        echoerr "No args expected! "
        exit 1
    fi
elif [ -n "$EXPECTED" ]; then
    ARG=$1
elif [ $# == 1 ]; then
    FEATUREBRANCH=$1
elif [ "$OPTFEATARG" == "y" ]; then
    FEATUREBRANCH=""
elif test "$DO" != 'n' && CURRENT=$(git symbolic-ref HEAD 2> /dev/null); then
    FEATUREBRANCH=${CURRENT##refs/heads/}
else
    usage
    exit 3
fi

if [ -n "$FEATUREBRANCH" ]; then
    FEATURE=$(basename $FEATUREBRANCH)
elif [[ -z "$EXPECTED" && -z "$OPTFEATARG" ]]; then
    echoerr "No feature name or branch provided!"
    exit 1
fi

################################################################################
#   Check and prepare environment
################################################################################

INST_VER=$(git config workflow.feature)
if [[ ! "$INST_VER" == "$VER" ]]; then
    echoerr "Feature is not installed or needs to be updated"
    echo "Run git feature -a init"
    exit -1
fi

if ! DEVREF=$(git config workflow.devref); then
    echoerr "The git config workflow.devref parameter must be define"
    exit 6
fi

DEVREFHASH=$(git rev-parse $DEVREF)
STARTNAMESPACE='start'
DRAFTNAMESPACE='draft'
FINALNAMESPACE='final'
FEATURESTART="$STARTNAMESPACE/$FEATURE"
FEATUREDRAFT="$DRAFTNAMESPACE/$FEATURE"
FEATUREFINAL="$FINALNAMESPACE/$FEATURE"

#Check if the feature name already exists
EXISTING="$(git show-ref $FEATURE)"
EXISTDRAFT="$(echo -e "$EXISTING" | grep "$FEATUREDRAFT" )"
EXISTFINAL="$(echo -e "$EXISTING" | grep "$FEATUREFINAL" )"

if [ ! "$FEATURE" == "$FEATUREBRANCH" ]; then
    FEATUREDIR=$(dirname $FEATUREBRANCH)
    FEATURENAMESPACE=$(basename $FEATUREDIR)
    FEATUREREMOTE=$(dirname $FEATUREDIR)

    if [[ ! ( "$FEATURENAMESPACE" == "$DRAFTNAMESPACE" || "$FEATURENAMESPACE" == "$FINALNAMESPACE" ) ]]; then
        echoerr "Invalid domain $FEATURENAMESPACE.\
            You must provide a $FEATUREDRAFT or a $FEATUREFINAL feature branch."
        exit 20
    fi
else
    if [[ $# == 0 && -z "$EXPECTED" && -z "$OPTFEATARG" ]]; then
        echoerr "You are not in a feature branch"
        echoerr "Either checkout the branch or provide the feature name in command line"
        exit 1
    fi

    FEATUREBRANCH=$DRAFTNAMESPACE/$FEATURE
fi

################################################################################
#   Function definitions
################################################################################

function list_feattags()
{
    START=$1
    END=$2
    git rev-list --simplify-by-decoration --pretty='format:%d' $START..$END \
        |sed '/@[^(),]\+_\w\+/!D;s/^\s*(\(@[^(),]\+_\w\+\).*$/\1/'
}

function is_local()
{
    git rev-parse refs/heads/$1 &> /dev/null && return 0
    return 1
}

function start_point()
{
    WORKINGBRANCH=$1
    STARTLIST=$(git show-ref $FEATURESTART)

    #Keep only start points that are in the branch
    SELECTSTART=''
    for s in $STARTLIST; do
        DISTANCE=$(git rev-list --count $s ^$WORKINGBRANCH)
        DISTANCEDEVREF=$(git rev-list --count $s ^$DEVREF)
        if [[ "$DISTANCE" == 0 && "$DISTANCEDEVREF" != 0 ]]; then
            SELECTSTART="$SELECTSTART$s "
        fi
    done
    STARTLIST=$SELECTSTART

    if [ -z "$STARTLIST" ]; then
        DEPEND="$(list_feat_depend $WORKINGBRANCH)"
        if [ -z "$DEPEND" ]; then
            START=$DEVREF
        else
            echoerr "Features are detected between $DEVREF and $WORKINGBRANCH but there is no 'start'" >&2
            echo 'marker *'"$FEATURESTART. Detected features are :" >&2
            echo -e "$DEPEND" >&2
            echo '------------------------------------------------------------' >&2
            echo 'You should check it before making operations on your feature' >&2
            exit 1
        fi
    else
        if [ "$(echo -e "$STARTLIST"|wc -l)" == 1 ]; then
            #If there is only one start point it is used
            START=$(echo -e "$STARTLIST" | sed 's#^.*refs/\w*/\(.*\)\s*$#\1#')
        elif echo -e "$STARTLIST" | grep refs/heads/$FEATURESTART &> /dev/null ; then
            #Is there a local start point
            START=$FEATURESTART
        else
            #A remote start point must be chosen
            echoerr "Several remote start points are found :" >&2
            echo -e "$STARTLIST" >&2
            echo '------------------------------------------------------------' >&2
            echo "Are you sure this is normal. If you are sure tell me wich I have to use by creating a local one" >&2
            exit 1
        fi
    fi
    echo $START
}

function feature_root()
{
    STARTPOINT=$(start_point $FEATUREBRANCH) || exit 1

    if [ "$STARTPOINT" == "$DEVREF" ]; then
        STARTPOINT=$(git merge-base "$DEVREF" "$FEATUREBRANCH")
    fi

    echo $STARTPOINT
}


#List features on which we are based
function list_feat_depend()
{
    WORKINGBRANCH=$1
    LIST=$(git rev-list  --simplify-by-decoration --pretty='format:%d' "$WORKINGBRANCH" "^$DEVREF" | \
        sed '/^\s*(/H;$!D;$g;s/[(), \n]\+/\n/g' | \
        sed "/$FEATURE"'$/D;'"/$DRAFTNAMESPACE"'\/\w*$/H;'"/$FINALNAMESPACE"'\/\w*$/H;$!D;$g' | \
        sed 's/^\s*$//')

    echo -e "$LIST"
}

function branch_list()
{
    git branch $@ | sed 's/^.\s*//'
}

function check_included()
{
    featbranch=$1
    featname=$(basename $featbranch)
    git rev-list $DEVREF ^$featbranch^ --simplify-by-decoration --pretty='format:%d' \
        |egrep '@'$featname'_[0-9]{1,}\b' &> /dev/null \
        && return 0

    return 1
}

function check_final()
{
    featname=$(basename $1)
    finalname=$FINALNAMESPACE/$featname
    finallist=$(branch_list --list $finalname)
    if [ -n "$finallist" ]; then
        finallist="$finallist "
    fi
    finallist=$finallist$(branch_list -r --contains $DEVREF --list '*/'$finalname)
    if [ -z "$finallist" ]; then
        finallist=$(branch_list -r --list '*/'$finalname)
    fi

    echo "$finallist"
}

function check_local()
{
    featname=$(basename $1)
    finalname=$FINALNAMESPACE/$featname
    draftname=$DRAFTNAMESPACE/$featname
    R=1
    if git rev-parse $finalname &> /dev/null; then
        echo $finalname
        R=0
    fi
    if git rev-parse $draftname &> /dev/null; then
        echo $draftname
        R=0
    fi

    return $R
}

function get_feat_ref()
{
    FEATREMOTE=$(git config branch."$FEATUREDRAFT".remote)
    FEATREBASE=$(git config branch."$FEATUREDRAFT".merge \
        | sed 's#refs/\w*/##')
    if [ -n "$FEATREBASE" ]; then
        if [ "$FEATREMOTE" == '.' ]; then
            echo "$FEATREBASE"
        else
            echo "$FEATREMOTE/$FEATREBASE"
        fi
    else
        echo "$DEVREF"
    fi
}

function list_locals()
{
    LOCALFEAT=$(branch_list --list 'draft/*')
    LOCALFEAT="$LOCALFEAT $(branch_list --list 'final/*')"
    FEATLIST=''
    for feat in $LOCALFEAT; do
        if ! check_included $feat; then
            finalfeat=$(check_final $feat)
            if [ -z "$finalfeat" ]; then
                FEATLIST="$FEATLIST$feat "
                FEATLIST="$FEATLIST$(branch_list -r --contains $DEVREF --list '*/'$feat) "
            else
                FEATLIST="$FEATLIST$finalfeat "
            fi
        fi
    done

    echo $FEATLIST
}

function list_remotes()
{
    REMOTENAME="$1"
    REMOTEFEAT=$(branch_list -r --list $1'/draft/*')
    REMOTEFEAT="$REMOTEFEAT $(branch_list -r --list $1'/final/*')"
    FEATLIST=''
    for feat in $REMOTEFEAT; do
        if ! check_included $feat; then
            finalfeat=$(check_final $feat)
            if [ -z "$finalfeat" ]; then
                FEATLIST="$FEATLIST$feat "
                FEATLIST="$FEATLIST$(check_local $feat) "
            else
                FEATLIST="$FEATLIST$finalfeat "
            fi
        fi
    done

    echo $FEATLIST
}

function list_updated_remote()
{
    REMOTEFEAT=$(branch_list -r --contains $DEVREF --list '*/draft/*')
    FEATLIST=''
    for feat in $REMOTEFEAT; do
        finalfeat=$(check_final $feat)
        if [ -z "$finalfeat" ]; then
            FEATLIST="$FEATLIST$finalfeat "
        else
            FEATLIST="$FEATLIST$feat "
        fi
    done

    echo $REMOTEFEAT
}

function check_remote()
{
    ERR=0
    REMOTE=$(git config workflow.remote)
    LIST=$(git branch -r --list "$REMOTE/$FINALNAMESPACE"'/*')
    LIST="$LIST $(git branch -r --list "$REMOTE/$DRAFTNAMESPACE"'/*')"
    for b in $LIST; do
        feat=$(basename $b)
        if git rev-parse $STARTNAMESPACE/$feat &> /dev/null; then
            if ! git rev-parse $REMOTE/$STARTNAMESPACE/$feat &> /dev/null; then
                echo "# > Feature $feat is not correctly pushed! You must run"
                echo "git push $REMOTE $STARTNAMESPACE/$feat"
                ERR=1
            fi
        fi
    done
    return $ERR
}

function push_feat()
{
    ARGFEAT=$(basename "$1")
    ARGFEATFINAL=$FINALNAMESPACE/$ARGFEAT
    ARGFEATDRAFT=$DRAFTNAMESPACE/$ARGFEAT
    ARGFEATSTART=$STARTNAMESPACE/$ARGFEAT
    REMOTE=$(git config workflow.remote)
    if git rev-parse $ARGFEATFINAL &> /dev/null; then
        git push -f $REMOTE $ARGFEATFINAL
        if git rev-parse $REMOTE/$ARGFEATDRAFT &> /dev/null; then
            git push -f $REMOTE :$ARGFEATDRAFT
        fi
    elif git show-rev $ARGFEATFINAL &> /dev/null; then 
        if git rev-parse $REMOTE/$ARGFEATDRAFT &> /dev/null; then
            git push -f $REMOTE :$ARGFEATDRAFT
        fi
    elif git rev-parse $ARGFEATDRAFT &> /dev/null; then
        git push -f $REMOTE $ARGFEATDRAFT
    fi 
    if git rev-parse $ARGFEATSTART &> /dev/null; then
        git push -f $REMOTE $ARGFEATSTART
    fi
}

function feat_stat()
{
    featbranch=$1
    featname=$(basename $1)

    if check_included $featbranch; then
        echo ">I : feature already integrated"
    elif [ -n "$(check_final $featbranch)" ]; then
        echo ">F : feature being finalized"
    elif ! git rev-parse draft/$featname &> /dev/null; then
        echo ">R : remote feature"
    else
        echo ">D : draft feature"
    fi

}

function feat_local_branches()
{
    BRANCHES=''
    featname=$1
    if git rev-parse draft/$featname &> /dev/null; then
        BRANCHES=" draft/$featname"'\n'
    fi
    if git rev-parse start/$featname &> /dev/null; then
        BRANCHES="$BRANCHES start/$featname"'\n'
    fi
    if git rev-parse final/$featname &> /dev/null; then
        BRANCHES="$BRANCHES final/$featname"'\n'
    fi

    echo "$BRANCHES"
}

function feat_list()
{
    ALLFEATS="$(branch_list --list 'final/*')"
    if [ "$2" != "l" ]; then
        ALLFEATS="$ALLFEATS"'\n'"$(branch_list -r --list '*/final/*')"
    fi
    ALLFEATS="$ALLFEATS"'\n'"$(branch_list --list 'draft/*')"
    if [ "$2" != "l" ]; then
        ALLFEATS="$ALLFEATS"'\n'"$(branch_list -r --list '*/draft/*')"
    fi

    ALLFEATS="$(echo -e "$ALLFEATS"|python "$PYPATH/filters.py")"


    #Separate included / not included features
    for feat in $ALLFEATS; do
        if check_included $feat; then
            FEATINC="$FEATINC$feat"'\n'
        else
            FEATCUR="$FEATCUR$(basename $feat)"'\n'
            FEATCURBRANCH="$FEATCURBRANCH$feat"'\n'
        fi
    done

    case "$1" in
        i)
            echo -e "$FEATINC"
            ;;
        c)
            echo -e "$FEATCUR"
            ;;
        b)
            echo -e "$FEATCURBRANCH"
            ;;
    esac
}


#Check the state of features on which we are based
# function check_feat_depend()
# {
# }

################################################################################
#   Proceed
################################################################################
if test "$DO" != 'p' && ! check_remote; then
    exit 1
fi


#Change DEVREF
if [ "$DO" == 'd' ]; then
    #git branch --contains $DEVREF
    if test -n "$ARG" && git rev-parse "$ARG" &> /dev/null ; then
        NEWREF=$ARG
        #Check if new reference contains old reference
        if [ -n "$(git rev-list $DEVREF ^$NEWREF)" ]; then
            echoerr "The new devel reference must contain $DEVREF"
            exit 1
        fi
    else
        CANDIDATES=$(git branch --contains $DEVREF | sed 's/^.\s*//')
        if [ -n "$CANDIDATES" ]; then
            CANDIDATES=$CANDIDATES"\n"
        fi
        CANDIDATES=$CANDIDATES$(git branch -r --contains $DEVREF | sed 's/^.\s*//')
        menuselect "$CANDIDATES" "Choose the main devel branch"
        NEWREF=$(<"$TMPFILE")
    fi

    echo ""
    echoimportant "New devel reference is $NEWREF"
    git config workflow.devref $NEWREF
    if is_local $NEWREF; then
        git update-ref refs/markers/devref $NEWREF
    fi
    exit

elif [ "$DO" == 'U' ]; then
    echo "Update remote devel reference : $DEVREF"
    git push $REMOTE $DEVREF && \
    git push $REMOTE $(list_feattags refs/markers/devref $DEVREF) && \
    git update-ref refs/markers/devref $DEVREF
    exit

elif [ "$DO" == 'diff' ]; then
    STARTPOINT=$(feature_root $FEATUREBRANCH) || exit 1
    git diff "$STARTPOINT" "$FEATUREBRANCH"
    exit

elif [ "$DO" == 'files' ]; then
    STARTPOINT=$(feature_root $FEATUREBRANCH) || exit 1
    git diff --name-only "$STARTPOINT" "$FEATUREBRANCH"
    exit

elif [ "$DO" == 's' ]; then
    feat_stat $FEATUREBRANCH
    exit

#Close the feature
elif [ "$DO" == 'C' ]; then
    if [ -z "$EXISTFINAL" ]; then
        echo -e $ERRCOL"The feature is not even finalized. "$NORMAL"Nothing to do!"
        exit 1
    fi

    if [ -z "$(git tag --list '@'$FEATURE'_*')" ]; then
        echoerr "Integration tag not found. The feature cannot be closed"
        exit 1
    fi

    git rev-parse $FEATUREDRAFT &> /dev/null && git branch -D $FEATUREDRAFT
    git rev-parse $FEATUREFINAL &> /dev/null && git branch -D $FEATUREFINAL
    git rev-parse $FEATURESTART &> /dev/null && git branch -D $FEATURESTART

    exit

elif [ "$DO" == 'Y' ]; then
    git rev-list --cherry-pick --right-only --pretty=full $DEVREF...$FEATUREBRANCH
    exit

elif [ "$DO" == 'D' ]; then
    LIST="$(feat_list 'i' 'l')"
    for feat in $LIST; do
        COMMITDATE=$(git log -n1 --pretty=format:%ct $feat)
        LASTCOMMIT=$(git log -n1 --pretty=format:%cr $feat|sed 's/ /_/g')
        SELECTLIST="$SELECTLIST$COMMITDATE $feat $(basename $feat):($LASTCOMMIT) off"'\n'
    done
    SELECTLIST=$(echo -e "$SELECTLIST"|sort -n|sed 's/^\w*\s*//')

    if ! multiselect "$SELECTLIST" "Select features you want to merge in test branch"; then
        SELECTED=''
    else
        SELECTED=$(sed 's/"//g;s/\\#/#/g' "$TMPFILE")
    fi

    if [ -z "$SELECTED" ]; then
        echo ""
        echo "No feature selected for cleaning"
        exit
    fi

    BRANCHLIST=''
    for feat in $SELECTED; do
        BRANCHLIST="$BRANCHLIST$(feat_local_branches $(basename $feat))"
    done

    TITLE="The following branches will be deleted. Are you sure?"
    if dialog --title "$TITLE" --yesno "$BRANCHLIST" 40 120; then
        BRANCHLIST=$(echo -e $BRANCHLIST)
        for branch in $BRANCHLIST; do
            echo " > Deleting $branch"
            git branch -D $branch
        done
        repeatchar 70 '-'
    else
        echo "Deletion canceled."
    fi
    exit


elif [ "$DO" == 'i' ]; then
    FEATREBASEDIR="$GITDIR/feat_rebase"
    if [ -f "$FEATREBASEDIR/integration" ]; then
        echoimportant "JUST CLEAN THE PREVIOUS INTEGRATION"
        FEATURE="$(<"$FEATREBASEDIR/integration")"
        POSTCHECKOUT="$(<"$FEATREBASEDIR/postcheckout")"
        test -n "$POSTCHECKOUT" && git checkout "$POSTCHECKOUT" &&
        test -n "$FEATURE" && git branch -D "integrate/$FEATURE" &&
        rm "$FEATREBASEDIR"/* &&
        echo "Integration succesfull"
        exit
    fi
    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "Your repository must be clean"
        echo "Please commit all changes before running it!"
        exit 2
    fi

    if ! CURRENT=$(git symbolic-ref HEAD 2> /dev/null); then
        echoerr "You must be in a valid local branch for include operation!"
        exit 1
    fi
    #Check current branch is not a feature
    if [[ "$CURRENT" =~ '/draft/' || "$CURRENT" =~ '/final/' ]]; then
        echoerr "You are in feature branch. Be carefull!"
        exit 2
    fi
    CURRENTBRANCH=${CURRENT##refs/heads/}

    if [ "$REVERSE" == "y" ]; then
        echo "Reverting last included feature..."
        TAGNAME=$(git tag -l --contains devel '@*_*')
        if [ -z "$TAGNAME" ]; then
            echoerr "No valid tag found!"
            exit 3
        fi
        echo " > Remove $TAGNAME and go back in $CURRENTBRANCH"
        git tag -d "$TAGNAME"
        git reset --hard $CURRENTBRANCH@{1}
        exit
    fi

    if [ -z "$FEATURE" ]; then
        echoerr "A feature must be specified!"
        exit 4
    fi

    echo "Including $FEATURE in $CURRENTBRANCH"
    if [ -z "$EXISTFINAL" ]; then
        echo "No final branch found for inclusion of $FEATURE"
        exit 1
    fi

    ABOVEREF=$(branch_list -a --contains $DEVREF --list '*'"$FEATUREFINAL")
    if [ $(echo -e "$EXISTFINAL" | wc -l) == 1 ]; then
        CHOSENFINAL=$(echo -e "$EXISTFINAL" | sed 's#^.*refs/\w*/\(.*\)\s*$#\1#')
    elif [[ -n "$ABOVEREF" && $(echo -e "$ABOVEREF" | wc -l) == 1 ]]; then
        CHOSENFINAL=$ABOVEREF
    else
        if ! menuselect "$EXISTFINAL" "Choose a final reference for the feature $FEATURE" -d; then
            exit
        fi
        CHOSENFINAL=$(sed '1!D;s#^.*refs/\w*/\(.*\)\s*$#\1#' "$TMPFILE")
    fi

    #Get NEWBASE SHA-1
    NEWBASE=$(git rev-parse HEAD)
    STARTPOINT=$(start_point $FEATUREBRANCH) || exit 1

    if [[ "$(git rev-parse $STARTPOINT)" == "$(git rev-parse HEAD)" && -z "$(git rev-list "^$CHOSENFINAL" "$DEVREF")" ]]; then
        git rebase $CHOSENFINAL
        git tag '@'$FEATURE"_$(date '+%s')"
    else
        FEATUREINTEGRATE=integrate/$FEATURE
        echo ''
        echo git branch -f $FEATUREINTEGRATE $CHOSENFINAL
        git branch -f $FEATUREINTEGRATE $CHOSENFINAL

        export INTEGRATION=$FEATURE
        export POSTCHECKOUT=$CURRENTBRANCH
        echo git rebase --onto $NEWBASE $STARTPOINT $FEATUREINTEGRATE
        git rebase --onto $NEWBASE $STARTPOINT $FEATUREINTEGRATE
    fi

    exit

#Push feature
elif [ "$DO" == 'p' ]; then
    push_feat "$FEATURE"
    exit

elif [ "$DO" == 'P' ]; then
    for feat in $(branch_list --list "$DRAFTNAMESPACE"/'*'); do
        if [ -z "$(git rev-parse "$FINALNAMESPACE/$feat" &> /dev/null)" ]; then
            push_feat $feat
        fi
    done

    for feat in $(branch_list --list "$FINALNAMESPACE"/'*'); do
        push_feat $feat
    done

    exit
        
#Check feature
elif [ "$DO" == 'c' ]; then
    exit

#View using gitk
elif [ "$DO" == 'v' ]; then
    BRANCHLIST=""
    echo "Getting list of branch ..."
    BRANCHLIST=$(list_locals)
    if [[ "$ALL" == 'y' || "$ARG" == all ]]; then
        BRANCHLIST="$BRANCHLIST $(list_updated_remote)"
    elif [ -n "$ARG" ]; then
        REMOTENAME="$ARG"
        BRANCHLIST="$(list_remotes $REMOTENAME)"
    fi
    BRANCHSELECT=''
    for feat in $BRANCHLIST; do
        if ! check_included $feat; then
            BRANCHSELECT="$BRANCHSELECT$feat "
        fi
    done
    BRANCHLIST=$BRANCHSELECT

    if [ "$FULL" == 'y' ]; then
        BRANCHLIST="$BRANCHLIST $DEVREF"
    else
        BRANCHLIST="$BRANCHLIST $DEVREF ^$DEVREF^"
    fi
    echo $BRANCHLIST
    echo "---------------------------------------"
    gitk $BRANCHLIST &

    exit

#List features
elif [ "$DO" == 'l' ]; then
    #If ARG is not empty it is the remote name
    if [ -z "$ARG" ]; then
        FEATLIST=$(branch_list --list 'draft/*')
        FEATPREFIX=''
    else
        FEATLIST=$(branch_list -r --list $ARG'/draft/*')
        FEATPREFIX=$ARG/
    fi

    CURRENT=''
    REMOTES=''
    INCLUDED=''
    FINALS=''

    for feat in $FEATLIST; do
        finalfeat=$(check_final $feat)
        if [ -z "$finalfeat" ]; then
            if ! check_included $feat; then
                CURRENT="$CURRENT$feat "
            else
                INCLUDED="$INCLUDED$feat "
            fi
        elif ! git rev-parse $FEATPREFIX'final/'$(basename $feat) &> /dev/null; then
            if ! check_included $feat; then
                FINALS="$FINALS$finalfeat "
            else
                INCLUDED="$INCLUDED$feat "
            fi
        fi
    done

    if [ -z "$ARG" ]; then
        FEATLIST=$(branch_list --list 'final/*')
    else
        FEATLIST=$(branch_list -r --list $ARG'/final/*')
    fi

    CURRENT=$CURRENT$HIGHLIGHT
    CURRENT="$CURRENT$FINALS "
    for feat in $FEATLIST; do
        if ! check_included $feat; then
            CURRENT="$CURRENT$feat "
        else
            INCLUDED="$INCLUDED$feat "
        fi
    done
    CURRENT=$CURRENT$NORMAL

    echo "List local features"
    echo ""
    echo -e $TITLE"Included features"$NORMAL
    for feat in $INCLUDED; do
        echo -e "    $ERRCOL$feat$NORMAL"
    done
    echo ""
    echo -e $TITLE"Current features"$NORMAL
    for feat in $CURRENT; do
        echo -e "    $feat"
    done
    echo ""

    exit 

#Finalize feature
elif [ "$DO" == 'f' ]; then
    if [ -z "$EXISTDRAFT" ]; then
        echoerr "No draft branch found for feature $FEATURE found!"
        exit 4
    fi

    if [ -n "$EXISTFINAL" ]; then
        echoerr "$FEATURE is already being finalized by you or someone else." ' *'/$FEATUREFINAL branches are detected.
        echo -e "$EXISTFINAL"
        exit 5
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point $FEATUREBRANCH) || exit 1

    git branch -t $FEATUREFINAL $STARTPOINT
    git branch -f $FEATUREFINAL $FEATUREBRANCH
    #Check if STARTPOINT is in DEVREF line
    if [ $(git rev-list --count $STARTPOINT ^$DEVREF) == 0 ]; then
        git rebase -i $DEVREF $FEATUREFINAL
    else
        #Unsure there is a local start point
        git branch -f $FEATURESTART $STARTPOINT
        git rebase -i $STARTPOINT $FEATUREFINAL
    fi

    exit
elif [ "$DO" == 'm' ]; then
    if [ -n "$EXISTFINAL" ]; then
        if ! git rev-parse $FEATUREFINAL &> /dev/null; then
            echoerr "$FEATURE is already being finalized by someone else." ' *'/$FEATUREFINAL branches are detected.
            echo -e "$EXISTFINAL"
            echo 'But there is no local final branch.'
            echo "You cannot move a remote final branch"
            exit 5
        fi
        FEATUREBRANCH=$FEATUREFINAL
    elif ! git rev-parse $FEATUREDRAFT &> /dev/null; then
        echoerr "No local branch $FEATUREDRAFT to move"
        exit 10
    else
        FEATUREBRANCH=$FEATUREDRAFT
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    echo '>> '$STARTPOINT

    #If there is start marker or if new base does not coincide with DEVREF,
    # a start_point must be created or moved
    if git show-ref $FEATURESTART &> /dev/null || test $(git rev-list --count ^$DEVREF $MOVETO) != 0
    then
        export NEWSTARTPOINT=$MOVETO
    fi
    echo git rebase --onto $MOVETO $STARTPOINT $FEATUREBRANCH
    git rebase --onto $MOVETO $STARTPOINT $FEATUREBRANCH
    exit

elif [ "$DO" == 'r' ]; then
    if [ -n "$EXISTFINAL" ]; then
        if ! git rev-parse $FEATUREFINAL &> /dev/null; then
            echoerr "$FEATURE is already being finalized by you or someone else." ' *'/$FEATUREFINAL branches are detected.
            echo -e "$EXISTFINAL"
            echo "You should not move a feature being finalizd"
            exit 5
        fi
        FEATUREBRANCH=$FEATUREFINAL
    elif ! git rev-parse $FEATUREDRAFT &> /dev/null; then
        echoerr "No local branch $FEATUREDRAFT to move"
        exit 10
    else
        FEATUREBRANCH=$FEATUREDRAFT
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    git checkout $FEATUREBRANCH
    git rebase -i $STARTPOINT
    exit

elif [ "$DO" == 'u' ]; then
    #Check if no final branch
    if [ -n "$EXISTFINAL" ]; then
        #Check if the branch is local
        if ! git rev-parse $FEATUREFINAL &> /dev/null; then
            echoerr "This operation can only be done on local final branch"
            exit 10
        fi
        FEATUREBRANCH=$FEATUREFINAL
    else
        #Check if the branch is local
        if ! git rev-parse $FEATUREDRAFT &> /dev/null; then
            echoerr "This operation can only be done on local draft branch"
            exit 10
        fi
        FEATUREBRANCH=$FEATUREDRAFT
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi


    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    FEATUREBASE=$(get_feat_ref)
    #TODO Check for other refs between start point and branch end.
    if [ "$(git rev-parse $STARTPOINT)" == "$DEVREFHASH" ]; then
        git checkout "$FEATUREBRANCH"
        git rebase $DEVREF
    elif [ -z "$(git rev-list ^$FEATUREBASE $DEVREF)" ]; then
        echo git rebase --onto "$FEATUREBASE" "$STARTPOINT" "$FEATUREBRANCH"
        git rebase --onto "$FEATUREBASE" "$STARTPOINT" "$FEATUREBRANCH"
    else
        echoerr "Previous feature $FEATUREBASE is not updated"
        echo "Rebase everything on devel"
        export BRANCHREPORT=$STARTPOINT
        git rebase $DEVREF $FEATUREBRANCH
    fi
    exit

elif [ "$DO" == 'e' ]; then
    # ====== Not used now =======
    if [ -z "$EXISTING" ]; then
        echoerr "No feature $FEATURE found!"
        exit 4
    fi

    dialog --menu "Choose which branch you to be based on" 40 100 15 1 $EXISTING 2> "$TMPFILE"

elif [ "$DO" == 'T' ]; then
    git branch -f testing_track testing &> /dev/null
    if [ "$(git symbolic-ref HEAD)" == "refs/heads/testing" ]; then
        git checkout testing_track
    fi
    if lasttest=$(git config workflow.lastref) && git config workflow.multipletest &> /dev/null ; then
        git branch $lasttest testing
    fi
    git branch -f testing $DEVREF
    testname=$(unicref test$(date +%d%m%y).)
    git config workflow.lastref $testname
    git checkout testing

    if [ -f "$GITDIR/test_merge" ]; then
        source "$GITDIR/test_merge"
    fi

    LIST="$(feat_list 'b')"
    SELECTLIST=''
    for feat in $LIST; do
        FLAG=''
        STAT='off'
        if [[ " $MERGEDFEAT " =~ " $feat " ]]; then
            STAT=on
        elif [[ " $NOTMERGEDFEAT " =~ " $feat " ]]; then
            STAT=on
            FLAG=':(!!)'
        fi
        COMMITDATE=$(git log -n1 --pretty=format:%ct $feat)
        SELECTLIST="$SELECTLIST$COMMITDATE $feat $(basename $feat)$FLAG $STAT"'\n'
    done
    SELECTLIST=$(echo -e "$SELECTLIST"|sort -nr|sed 's/^\w*\s*//')
    if ! multiselect "$SELECTLIST" "Select features you want to merge in test branch"; then
        SELECTED=''
    else
        SELECTED=$(sed 's/"//g;s/\\#/#/g' "$TMPFILE")
    fi

    if [ -z "$SELECTED" ]; then
        echo ""
        echo "No merge selected"
        exit
    fi

    echo ""
    echo "Performing selected merges : "
    MERGEDFEAT=''
    NOTMERGEDFEAT=''

    for feat in $SELECTED; do
        echo ""
        repeatchar 60 '#'
        echo -e "#    $HIGHLIGHT Merging $feat$NORMAL"
        repeatchar 60 '#'
        if git merge $feat; then
            MERGEDFEAT="$MERGEDFEAT$feat "
        else
            git reset --hard
            echo -e "$ERRCOL$feat could not be merged because of a conflict.$NORMAL"
            NOTMERGEDFEAT="$NOTMERGEDFEAT$feat "
        fi
    done
    echo -e ""
    repeatchar 60 '='
    echo 'Test branch generated by git feature with merge' > "$TMPFILE"
    echo '' >> "$TMPFILE"
    if [ -n "$MERGEDFEAT" ]; then
        echo -e "$TITLE Following features where successfully merged:$NORMAL$BOLD"
        echo "* Following features where successfully merged:" >> "$TMPFILE"
        for feat in $MERGEDFEAT; do echo -e "   > $feat"; done
        for feat in $MERGEDFEAT; do echo -e "   > $feat"; done >> "$TMPFILE"
        echo -e "$NORMAL"
        echo "" >> "$TMPFILE"
    fi
    echo -e ""
    if [ -n "$NOTMERGEDFEAT" ]; then
        echo -e "$TITLE Following features failled:$ERRCOL"
        echo -e "* Following features failled:" >> "$TMPFILE"
        for feat in $NOTMERGEDFEAT; do echo -e "   > $feat"; done
        for feat in $NOTMERGEDFEAT; do echo -e "   > $feat"; done >> "$TMPFILE"
        echo -e "$NORMAL"
    fi

    git commit --allow-empty -F "$TMPFILE"
    git branch -f testing_track

    echo "MERGEDFEAT='$MERGEDFEAT'" > "$GITDIR/test_merge"
    echo "NOTMERGEDFEAT='$NOTMERGEDFEAT'" >> "$GITDIR/test_merge"
    repeatchar 60 '='

    exit

elif [ "$DO" == 'L' ]; then
    feat_list 'b'
    exit

elif [ "$DO" == 't' ]; then
    echo FEATURE      : $FEATURE
    echo DEVREF       : $DEVREF
    echo DEVREFHASH   : $DEVREFHASH
    echo STARTNAMESPACE  : $STARTNAMESPACE
    echo DRAFTNAMESPACE  : $DRAFTNAMESPACE
    echo FINALNAMESPACE  : $FINALNAMESPACE
    echo FEATURESTART : $FEATURESTART
    echo FEATUREDRAFT : $FEATUREDRAFT
    echo FEATUREFINAL : $FEATUREFINAL
    echo EXISTING     : $EXISTING
    echo EXISTDRAFT   : $EXISTDRAFT
    echo EXISTFINAL   : $EXISTFINAL
    echo FEATUREDIR   : $FEATUREDIR
    echo FEATUREBRANCH : $FEATUREBRANCH
    echo FEATURENAMESPACE : $FEATURENAMESPACE
    echo FEATUREREMOTE : $FEATUREREMOTE

    echoimportant 'start > '$(start_point $FEATUREBRANCH)
    echowarn "Do nothing ..."
    exit

else
    if [ -n "$EXISTING" ]; then
        echoerr "The name $FEATURE has been found in existing branches"
        echo "Choose another name for your new feature"
        exit 5
    fi

    if [ -z "$FOLLOW" ]; then
        FOLLOW="$DEVREF"
    fi
fi

DISTANCE=$(git rev-list --count $DEVREF ^$FOLLOW)
if [ ! "$DISTANCE" == 0 ]; then
    echoerr "Your base must contain the main devel branch : $DEVREF"
    echo "Ensure your base is correct and / or rebase it if needed before creating your new feature"
    exit 7
fi

if [ ! "$(git rev-parse $FOLLOW)" == "$DEVREFHASH" ]; then
    echoerr "Provide distant start point"
    git branch $FEATURESTART $FOLLOW
fi
git branch -t $FEATUREDRAFT $FOLLOW
git config branch.$FEATUREDRAFT.rebase true

echo "You can now implement your new feature in branch $FEATUREDRAFT"

#Check if repo is clean
if ! git diff --quiet HEAD; then
    echowarn "It can't be checked out now because your repository is not clean now"
    echo "you can get it by > git checkout $FEATUREDRAFT"
    echo "but you should FIRST CLEAN YOUR REPOSITORY"
else
    git checkout $FEATUREDRAFT
fi


